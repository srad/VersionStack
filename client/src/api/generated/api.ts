/* tslint:disable */
/* eslint-disable */
/**
 * VersionStack API
 * A self-hosted file versioning and delivery system for managing application binaries, firmware updates, or any versioned files.  ## Authentication Most endpoints require JWT authentication. Obtain a token via `POST /auth/login` and include it in the `Authorization` header: ``` Authorization: Bearer <token> ```  ## API Versioning The current API version is **v1**. All endpoints are prefixed with `/api/v1/`. Legacy endpoints under `/api/` are deprecated and will be removed in future versions.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface ApiKey {
    'id': number;
    'name': string;
    'permission': ApiKeyPermissionEnum;
    /**
     * Null for global access, or array of app keys
     */
    'appScope': Array<string> | null;
    'isActive': boolean;
    'createdAt': string;
    'lastUsedAt': string | null;
}

export const ApiKeyPermissionEnum = {
    Read: 'read',
    Write: 'write',
    Admin: 'admin'
} as const;

export type ApiKeyPermissionEnum = typeof ApiKeyPermissionEnum[keyof typeof ApiKeyPermissionEnum];

export interface App {
    'id': number;
    'appKey': string;
    'displayName': string | null;
    'currentVersionId': number | null;
    /**
     * Whether the /latest endpoint is publicly accessible without authentication
     */
    'isPublic': boolean;
    'createdAt': string;
}
export interface AuditLogEntry {
    'id': number;
    /**
     * The action that was performed
     */
    'action': string;
    /**
     * Type of entity affected (app, version, api_key, auth)
     */
    'entityType': string;
    /**
     * Identifier of the affected entity
     */
    'entityId': string | null;
    /**
     * ID of the API key that performed the action (null for bootstrap admin)
     */
    'actorKeyId': number | null;
    /**
     * Name of the API key that performed the action
     */
    'actorKeyName': string | null;
    /**
     * IP address of the request
     */
    'actorIp': string | null;
    /**
     * Additional details about the action
     */
    'details': { [key: string]: any | null; } | null;
    'createdAt': string;
}
export interface AuditLogPagination {
    'total': number;
    'limit': number;
    'offset': number;
}
export interface AuditLogResponse {
    'data': Array<AuditLogEntry>;
    'pagination': AuditLogPagination;
}
export interface CreateApiKeyRequest {
    /**
     * Human-readable name for the key
     */
    'name': string;
    /**
     * Permission level: read, write, or admin
     */
    'permission': CreateApiKeyRequestPermissionEnum;
    /**
     * Limit key to specific apps (omit for global access)
     */
    'appScope'?: Array<string>;
}

export const CreateApiKeyRequestPermissionEnum = {
    Read: 'read',
    Write: 'write',
    Admin: 'admin'
} as const;

export type CreateApiKeyRequestPermissionEnum = typeof CreateApiKeyRequestPermissionEnum[keyof typeof CreateApiKeyRequestPermissionEnum];

export interface CreateApiKeyResponse {
    'id': number;
    /**
     * The API key - shown only once at creation!
     */
    'apiKey': string;
    'name': string;
    'permission': CreateApiKeyResponsePermissionEnum;
    'appScope': Array<string> | null;
    'isActive': boolean;
    'createdAt': string;
    'lastUsedAt': string | null;
}

export const CreateApiKeyResponsePermissionEnum = {
    Read: 'read',
    Write: 'write',
    Admin: 'admin'
} as const;

export type CreateApiKeyResponsePermissionEnum = typeof CreateApiKeyResponsePermissionEnum[keyof typeof CreateApiKeyResponsePermissionEnum];

export interface CreateAppRequest {
    /**
     * Unique identifier (alphanumeric with dashes)
     */
    'appKey': string;
    /**
     * Human-readable name
     */
    'displayName'?: string;
    /**
     * Whether the /latest endpoint is publicly accessible (default: false)
     */
    'isPublic'?: boolean;
}
export interface DeleteAppResponse {
    'message': string;
    'deleted': DeleteAppResponseDeleted;
}
export interface DeleteAppResponseDeleted {
    'appKey': string;
    'versionsCount': number;
}
export interface HealthStatus {
    'status': HealthStatusStatusEnum;
    'timestamp': string;
    'uptime': number;
    'version': string;
    'checks': HealthStatusChecks;
}

export const HealthStatusStatusEnum = {
    Healthy: 'healthy',
    Degraded: 'degraded',
    Unhealthy: 'unhealthy'
} as const;

export type HealthStatusStatusEnum = typeof HealthStatusStatusEnum[keyof typeof HealthStatusStatusEnum];

export interface HealthStatusChecks {
    'database': HealthStatusChecksDatabase;
}
export interface HealthStatusChecksDatabase {
    'status': HealthStatusChecksDatabaseStatusEnum;
    'latency_ms'?: number;
    'error'?: string;
}

export const HealthStatusChecksDatabaseStatusEnum = {
    Up: 'up',
    Down: 'down'
} as const;

export type HealthStatusChecksDatabaseStatusEnum = typeof HealthStatusChecksDatabaseStatusEnum[keyof typeof HealthStatusChecksDatabaseStatusEnum];

export interface LatestVersion {
    'version': string;
    'createdAt': string;
    'files': Array<LatestVersionFile>;
}
export interface LatestVersionFile {
    'fileName': string;
    'hash': string;
    'hashAlgorithm': LatestVersionFileHashAlgorithmEnum;
    'size': number;
    'downloadUrl': string;
}

export const LatestVersionFileHashAlgorithmEnum = {
    Sha256: 'sha256'
} as const;

export type LatestVersionFileHashAlgorithmEnum = typeof LatestVersionFileHashAlgorithmEnum[keyof typeof LatestVersionFileHashAlgorithmEnum];

export interface Liveness {
    'status': LivenessStatusEnum;
    'timestamp': string;
}

export const LivenessStatusEnum = {
    Alive: 'alive'
} as const;

export type LivenessStatusEnum = typeof LivenessStatusEnum[keyof typeof LivenessStatusEnum];

export interface LoginRequest {
    /**
     * Your API key
     */
    'apiKey': string;
}
export interface LoginResponse {
    'token': string;
    'expiresIn': string;
}
export interface MessageResponse {
    'message': string;
}
export interface ModelError {
    'code': string;
    'message': string;
    'details'?: { [key: string]: Array<string>; };
}
export interface Readiness {
    'status': ReadinessStatusEnum;
    'timestamp': string;
}

export const ReadinessStatusEnum = {
    Ready: 'ready'
} as const;

export type ReadinessStatusEnum = typeof ReadinessStatusEnum[keyof typeof ReadinessStatusEnum];

export interface SetActiveVersionRequest {
    /**
     * ID of the version to set as active
     */
    'versionId': number;
}
export interface Stats {
    /**
     * Total number of registered applications
     */
    'totalApps': number;
    /**
     * Total number of versions across all applications
     */
    'totalVersions': number;
    /**
     * Total storage used by all files in bytes
     */
    'totalStorageBytes': number;
    /**
     * Number of applications that have an active version set
     */
    'appsWithActiveVersion': number;
    /**
     * Number of version uploads in the last 7 days
     */
    'recentUploads': number;
}
export interface UpdateAppRequest {
    'displayName'?: string;
    /**
     * Whether the /latest endpoint is publicly accessible
     */
    'isPublic'?: boolean;
}
export interface UploadVersionResponse {
    'message': string;
    'version': string;
    'files': Array<VersionFile>;
}
export interface Version {
    'id': number;
    'versionName': string;
    'isActive': boolean;
    'createdAt': string;
    'files': Array<VersionFile>;
}
export interface VersionFile {
    'id': number;
    'fileName': string;
    'fileHash': string;
    'fileSize': number;
    'hashAlgorithm': VersionFileHashAlgorithmEnum;
    'downloadUrl': string;
}

export const VersionFileHashAlgorithmEnum = {
    Sha256: 'sha256'
} as const;

export type VersionFileHashAlgorithmEnum = typeof VersionFileHashAlgorithmEnum[keyof typeof VersionFileHashAlgorithmEnum];


/**
 * APIKeysApi - axios parameter creator
 */
export const APIKeysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve all API keys. Requires admin permission.
         * @summary List all API keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authApiKeysGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/api-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke (soft-delete) an API key. Requires admin permission.
         * @summary Revoke an API key
         * @param {string} keyId API Key ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authApiKeysKeyIdDelete: async (keyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyId' is not null or undefined
            assertParamExists('authApiKeysKeyIdDelete', 'keyId', keyId)
            const localVarPath = `/auth/api-keys/{keyId}`
                .replace(`{${"keyId"}}`, encodeURIComponent(String(keyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new API key with specified permissions. The key is shown only once in the response. Requires admin permission.
         * @summary Create a new API key
         * @param {CreateApiKeyRequest} [createApiKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authApiKeysPost: async (createApiKeyRequest?: CreateApiKeyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/api-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createApiKeyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APIKeysApi - functional programming interface
 */
export const APIKeysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = APIKeysApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve all API keys. Requires admin permission.
         * @summary List all API keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authApiKeysGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiKey>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authApiKeysGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIKeysApi.authApiKeysGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revoke (soft-delete) an API key. Requires admin permission.
         * @summary Revoke an API key
         * @param {string} keyId API Key ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authApiKeysKeyIdDelete(keyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authApiKeysKeyIdDelete(keyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIKeysApi.authApiKeysKeyIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new API key with specified permissions. The key is shown only once in the response. Requires admin permission.
         * @summary Create a new API key
         * @param {CreateApiKeyRequest} [createApiKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authApiKeysPost(createApiKeyRequest?: CreateApiKeyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateApiKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authApiKeysPost(createApiKeyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['APIKeysApi.authApiKeysPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * APIKeysApi - factory interface
 */
export const APIKeysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = APIKeysApiFp(configuration)
    return {
        /**
         * Retrieve all API keys. Requires admin permission.
         * @summary List all API keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authApiKeysGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<ApiKey>> {
            return localVarFp.authApiKeysGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke (soft-delete) an API key. Requires admin permission.
         * @summary Revoke an API key
         * @param {string} keyId API Key ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authApiKeysKeyIdDelete(keyId: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponse> {
            return localVarFp.authApiKeysKeyIdDelete(keyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new API key with specified permissions. The key is shown only once in the response. Requires admin permission.
         * @summary Create a new API key
         * @param {CreateApiKeyRequest} [createApiKeyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authApiKeysPost(createApiKeyRequest?: CreateApiKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateApiKeyResponse> {
            return localVarFp.authApiKeysPost(createApiKeyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * APIKeysApi - object-oriented interface
 */
export class APIKeysApi extends BaseAPI {
    /**
     * Retrieve all API keys. Requires admin permission.
     * @summary List all API keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authApiKeysGet(options?: RawAxiosRequestConfig) {
        return APIKeysApiFp(this.configuration).authApiKeysGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revoke (soft-delete) an API key. Requires admin permission.
     * @summary Revoke an API key
     * @param {string} keyId API Key ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authApiKeysKeyIdDelete(keyId: string, options?: RawAxiosRequestConfig) {
        return APIKeysApiFp(this.configuration).authApiKeysKeyIdDelete(keyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new API key with specified permissions. The key is shown only once in the response. Requires admin permission.
     * @summary Create a new API key
     * @param {CreateApiKeyRequest} [createApiKeyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authApiKeysPost(createApiKeyRequest?: CreateApiKeyRequest, options?: RawAxiosRequestConfig) {
        return APIKeysApiFp(this.configuration).authApiKeysPost(createApiKeyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AppsApi - axios parameter creator
 */
export const AppsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete an application and all its versions and files.
         * @summary Delete application
         * @param {string} appKey Unique application key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsAppKeyDelete: async (appKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appKey' is not null or undefined
            assertParamExists('appsAppKeyDelete', 'appKey', appKey)
            const localVarPath = `/apps/{appKey}`
                .replace(`{${"appKey"}}`, encodeURIComponent(String(appKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details of a specific application by its key.
         * @summary Get application details
         * @param {string} appKey Unique application key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsAppKeyGet: async (appKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appKey' is not null or undefined
            assertParamExists('appsAppKeyGet', 'appKey', appKey)
            const localVarPath = `/apps/{appKey}`
                .replace(`{${"appKey"}}`, encodeURIComponent(String(appKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the display name of an existing application.
         * @summary Update application metadata
         * @param {string} appKey Unique application key
         * @param {UpdateAppRequest} [updateAppRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsAppKeyPut: async (appKey: string, updateAppRequest?: UpdateAppRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appKey' is not null or undefined
            assertParamExists('appsAppKeyPut', 'appKey', appKey)
            const localVarPath = `/apps/{appKey}`
                .replace(`{${"appKey"}}`, encodeURIComponent(String(appKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAppRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all registered applications.
         * @summary List all applications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/apps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register a new application in the system.
         * @summary Create a new application
         * @param {CreateAppRequest} [createAppRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsPost: async (createAppRequest?: CreateAppRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/apps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAppRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppsApi - functional programming interface
 */
export const AppsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AppsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete an application and all its versions and files.
         * @summary Delete application
         * @param {string} appKey Unique application key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appsAppKeyDelete(appKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAppResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appsAppKeyDelete(appKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppsApi.appsAppKeyDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve details of a specific application by its key.
         * @summary Get application details
         * @param {string} appKey Unique application key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appsAppKeyGet(appKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<App>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appsAppKeyGet(appKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppsApi.appsAppKeyGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the display name of an existing application.
         * @summary Update application metadata
         * @param {string} appKey Unique application key
         * @param {UpdateAppRequest} [updateAppRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appsAppKeyPut(appKey: string, updateAppRequest?: UpdateAppRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<App>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appsAppKeyPut(appKey, updateAppRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppsApi.appsAppKeyPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all registered applications.
         * @summary List all applications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<App>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppsApi.appsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Register a new application in the system.
         * @summary Create a new application
         * @param {CreateAppRequest} [createAppRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appsPost(createAppRequest?: CreateAppRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<App>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appsPost(createAppRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppsApi.appsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AppsApi - factory interface
 */
export const AppsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AppsApiFp(configuration)
    return {
        /**
         * Delete an application and all its versions and files.
         * @summary Delete application
         * @param {string} appKey Unique application key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsAppKeyDelete(appKey: string, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAppResponse> {
            return localVarFp.appsAppKeyDelete(appKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve details of a specific application by its key.
         * @summary Get application details
         * @param {string} appKey Unique application key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsAppKeyGet(appKey: string, options?: RawAxiosRequestConfig): AxiosPromise<App> {
            return localVarFp.appsAppKeyGet(appKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the display name of an existing application.
         * @summary Update application metadata
         * @param {string} appKey Unique application key
         * @param {UpdateAppRequest} [updateAppRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsAppKeyPut(appKey: string, updateAppRequest?: UpdateAppRequest, options?: RawAxiosRequestConfig): AxiosPromise<App> {
            return localVarFp.appsAppKeyPut(appKey, updateAppRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all registered applications.
         * @summary List all applications
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<App>> {
            return localVarFp.appsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Register a new application in the system.
         * @summary Create a new application
         * @param {CreateAppRequest} [createAppRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsPost(createAppRequest?: CreateAppRequest, options?: RawAxiosRequestConfig): AxiosPromise<App> {
            return localVarFp.appsPost(createAppRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AppsApi - object-oriented interface
 */
export class AppsApi extends BaseAPI {
    /**
     * Delete an application and all its versions and files.
     * @summary Delete application
     * @param {string} appKey Unique application key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public appsAppKeyDelete(appKey: string, options?: RawAxiosRequestConfig) {
        return AppsApiFp(this.configuration).appsAppKeyDelete(appKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve details of a specific application by its key.
     * @summary Get application details
     * @param {string} appKey Unique application key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public appsAppKeyGet(appKey: string, options?: RawAxiosRequestConfig) {
        return AppsApiFp(this.configuration).appsAppKeyGet(appKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the display name of an existing application.
     * @summary Update application metadata
     * @param {string} appKey Unique application key
     * @param {UpdateAppRequest} [updateAppRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public appsAppKeyPut(appKey: string, updateAppRequest?: UpdateAppRequest, options?: RawAxiosRequestConfig) {
        return AppsApiFp(this.configuration).appsAppKeyPut(appKey, updateAppRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all registered applications.
     * @summary List all applications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public appsGet(options?: RawAxiosRequestConfig) {
        return AppsApiFp(this.configuration).appsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register a new application in the system.
     * @summary Create a new application
     * @param {CreateAppRequest} [createAppRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public appsPost(createAppRequest?: CreateAppRequest, options?: RawAxiosRequestConfig) {
        return AppsApiFp(this.configuration).appsPost(createAppRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuditApi - axios parameter creator
 */
export const AuditApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve audit log entries for security monitoring. Admin only.
         * @summary Get audit log
         * @param {string} [action] Filter by action type
         * @param {string} [entityType] Filter by entity type (app, version, api_key, auth)
         * @param {string} [entityId] Filter by entity ID
         * @param {string} [limit] Number of entries to return (default: 100)
         * @param {string} [offset] Offset for pagination (default: 0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auditGet: async (action?: string, entityType?: string, entityId?: string, limit?: string, offset?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/audit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }

            if (entityType !== undefined) {
                localVarQueryParameter['entityType'] = entityType;
            }

            if (entityId !== undefined) {
                localVarQueryParameter['entityId'] = entityId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuditApi - functional programming interface
 */
export const AuditApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuditApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve audit log entries for security monitoring. Admin only.
         * @summary Get audit log
         * @param {string} [action] Filter by action type
         * @param {string} [entityType] Filter by entity type (app, version, api_key, auth)
         * @param {string} [entityId] Filter by entity ID
         * @param {string} [limit] Number of entries to return (default: 100)
         * @param {string} [offset] Offset for pagination (default: 0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async auditGet(action?: string, entityType?: string, entityId?: string, limit?: string, offset?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuditLogResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.auditGet(action, entityType, entityId, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuditApi.auditGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuditApi - factory interface
 */
export const AuditApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuditApiFp(configuration)
    return {
        /**
         * Retrieve audit log entries for security monitoring. Admin only.
         * @summary Get audit log
         * @param {string} [action] Filter by action type
         * @param {string} [entityType] Filter by entity type (app, version, api_key, auth)
         * @param {string} [entityId] Filter by entity ID
         * @param {string} [limit] Number of entries to return (default: 100)
         * @param {string} [offset] Offset for pagination (default: 0)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auditGet(action?: string, entityType?: string, entityId?: string, limit?: string, offset?: string, options?: RawAxiosRequestConfig): AxiosPromise<AuditLogResponse> {
            return localVarFp.auditGet(action, entityType, entityId, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuditApi - object-oriented interface
 */
export class AuditApi extends BaseAPI {
    /**
     * Retrieve audit log entries for security monitoring. Admin only.
     * @summary Get audit log
     * @param {string} [action] Filter by action type
     * @param {string} [entityType] Filter by entity type (app, version, api_key, auth)
     * @param {string} [entityId] Filter by entity ID
     * @param {string} [limit] Number of entries to return (default: 100)
     * @param {string} [offset] Offset for pagination (default: 0)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public auditGet(action?: string, entityType?: string, entityId?: string, limit?: string, offset?: string, options?: RawAxiosRequestConfig) {
        return AuditApiFp(this.configuration).auditGet(action, entityType, entityId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthenticationApi - axios parameter creator
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticate with an API key to receive a JWT token for API access.
         * @summary Authenticate with API key and get JWT token
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost: async (loginRequest?: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * Authenticate with an API key to receive a JWT token for API access.
         * @summary Authenticate with API key and get JWT token
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLoginPost(loginRequest?: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLoginPost(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authLoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * Authenticate with an API key to receive a JWT token for API access.
         * @summary Authenticate with API key and get JWT token
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost(loginRequest?: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponse> {
            return localVarFp.authLoginPost(loginRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * Authenticate with an API key to receive a JWT token for API access.
     * @summary Authenticate with API key and get JWT token
     * @param {LoginRequest} [loginRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authLoginPost(loginRequest?: LoginRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authLoginPost(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthApi - axios parameter creator
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get comprehensive health status including database connectivity.
         * @summary Full health status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Kubernetes liveness probe - checks if the application is running.
         * @summary Liveness probe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthLiveGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/live`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Kubernetes readiness probe - checks if the application can serve traffic.
         * @summary Readiness probe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthReadyGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/ready`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * Get comprehensive health status including database connectivity.
         * @summary Full health status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.healthGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Kubernetes liveness probe - checks if the application is running.
         * @summary Liveness probe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthLiveGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Liveness>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthLiveGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.healthLiveGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Kubernetes readiness probe - checks if the application can serve traffic.
         * @summary Readiness probe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthReadyGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Readiness>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthReadyGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.healthReadyGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * Get comprehensive health status including database connectivity.
         * @summary Full health status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthGet(options?: RawAxiosRequestConfig): AxiosPromise<HealthStatus> {
            return localVarFp.healthGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Kubernetes liveness probe - checks if the application is running.
         * @summary Liveness probe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthLiveGet(options?: RawAxiosRequestConfig): AxiosPromise<Liveness> {
            return localVarFp.healthLiveGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Kubernetes readiness probe - checks if the application can serve traffic.
         * @summary Readiness probe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthReadyGet(options?: RawAxiosRequestConfig): AxiosPromise<Readiness> {
            return localVarFp.healthReadyGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 */
export class HealthApi extends BaseAPI {
    /**
     * Get comprehensive health status including database connectivity.
     * @summary Full health status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public healthGet(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).healthGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Kubernetes liveness probe - checks if the application is running.
     * @summary Liveness probe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public healthLiveGet(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).healthLiveGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Kubernetes readiness probe - checks if the application can serve traffic.
     * @summary Readiness probe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public healthReadyGet(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).healthReadyGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StatsApi - axios parameter creator
 */
export const StatsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve aggregated statistics for the dashboard including total apps, versions, storage usage, and recent activity.
         * @summary Get dashboard statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatsApi - functional programming interface
 */
export const StatsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve aggregated statistics for the dashboard including total apps, versions, storage usage, and recent activity.
         * @summary Get dashboard statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Stats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatsApi.statsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StatsApi - factory interface
 */
export const StatsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatsApiFp(configuration)
    return {
        /**
         * Retrieve aggregated statistics for the dashboard including total apps, versions, storage usage, and recent activity.
         * @summary Get dashboard statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsGet(options?: RawAxiosRequestConfig): AxiosPromise<Stats> {
            return localVarFp.statsGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatsApi - object-oriented interface
 */
export class StatsApi extends BaseAPI {
    /**
     * Retrieve aggregated statistics for the dashboard including total apps, versions, storage usage, and recent activity.
     * @summary Get dashboard statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public statsGet(options?: RawAxiosRequestConfig) {
        return StatsApiFp(this.configuration).statsGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VersionsApi - axios parameter creator
 */
export const VersionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Set a specific version as the active (current) version for the application.
         * @summary Set active version
         * @param {string} appKey Unique application key
         * @param {SetActiveVersionRequest} [setActiveVersionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsAppKeyActiveVersionPut: async (appKey: string, setActiveVersionRequest?: SetActiveVersionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appKey' is not null or undefined
            assertParamExists('appsAppKeyActiveVersionPut', 'appKey', appKey)
            const localVarPath = `/apps/{appKey}/active-version`
                .replace(`{${"appKey"}}`, encodeURIComponent(String(appKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setActiveVersionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Public endpoint to get the currently active version for an application. Used by clients/devices to check for updates.
         * @summary Get latest (active) version
         * @param {string} appKey Unique application key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsAppKeyLatestGet: async (appKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appKey' is not null or undefined
            assertParamExists('appsAppKeyLatestGet', 'appKey', appKey)
            const localVarPath = `/apps/{appKey}/latest`
                .replace(`{${"appKey"}}`, encodeURIComponent(String(appKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all versions for an application with their files.
         * @summary List all versions
         * @param {string} appKey Unique application key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsAppKeyVersionsGet: async (appKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appKey' is not null or undefined
            assertParamExists('appsAppKeyVersionsGet', 'appKey', appKey)
            const localVarPath = `/apps/{appKey}/versions`
                .replace(`{${"appKey"}}`, encodeURIComponent(String(appKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload one or more files as a new version. Automatically sets as active version.
         * @summary Upload new version
         * @param {string} appKey Unique application key
         * @param {Array<File>} files Files to upload
         * @param {string} [versionName] Version name (auto-generated if not provided)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsAppKeyVersionsPost: async (appKey: string, files: Array<File>, versionName?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appKey' is not null or undefined
            assertParamExists('appsAppKeyVersionsPost', 'appKey', appKey)
            // verify required parameter 'files' is not null or undefined
            assertParamExists('appsAppKeyVersionsPost', 'files', files)
            const localVarPath = `/apps/{appKey}/versions`
                .replace(`{${"appKey"}}`, encodeURIComponent(String(appKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }


            if (versionName !== undefined) { 
                localVarFormParams.append('versionName', versionName as any);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific version and its files. Cannot delete the active version.
         * @summary Delete version
         * @param {string} appKey Unique application key
         * @param {string} versionId Version ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsAppKeyVersionsVersionIdDelete: async (appKey: string, versionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appKey' is not null or undefined
            assertParamExists('appsAppKeyVersionsVersionIdDelete', 'appKey', appKey)
            // verify required parameter 'versionId' is not null or undefined
            assertParamExists('appsAppKeyVersionsVersionIdDelete', 'versionId', versionId)
            const localVarPath = `/apps/{appKey}/versions/{versionId}`
                .replace(`{${"appKey"}}`, encodeURIComponent(String(appKey)))
                .replace(`{${"versionId"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VersionsApi - functional programming interface
 */
export const VersionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VersionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Set a specific version as the active (current) version for the application.
         * @summary Set active version
         * @param {string} appKey Unique application key
         * @param {SetActiveVersionRequest} [setActiveVersionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appsAppKeyActiveVersionPut(appKey: string, setActiveVersionRequest?: SetActiveVersionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appsAppKeyActiveVersionPut(appKey, setActiveVersionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VersionsApi.appsAppKeyActiveVersionPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Public endpoint to get the currently active version for an application. Used by clients/devices to check for updates.
         * @summary Get latest (active) version
         * @param {string} appKey Unique application key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appsAppKeyLatestGet(appKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LatestVersion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appsAppKeyLatestGet(appKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VersionsApi.appsAppKeyLatestGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all versions for an application with their files.
         * @summary List all versions
         * @param {string} appKey Unique application key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appsAppKeyVersionsGet(appKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Version>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appsAppKeyVersionsGet(appKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VersionsApi.appsAppKeyVersionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload one or more files as a new version. Automatically sets as active version.
         * @summary Upload new version
         * @param {string} appKey Unique application key
         * @param {Array<File>} files Files to upload
         * @param {string} [versionName] Version name (auto-generated if not provided)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appsAppKeyVersionsPost(appKey: string, files: Array<File>, versionName?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appsAppKeyVersionsPost(appKey, files, versionName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VersionsApi.appsAppKeyVersionsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a specific version and its files. Cannot delete the active version.
         * @summary Delete version
         * @param {string} appKey Unique application key
         * @param {string} versionId Version ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appsAppKeyVersionsVersionIdDelete(appKey: string, versionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appsAppKeyVersionsVersionIdDelete(appKey, versionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VersionsApi.appsAppKeyVersionsVersionIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VersionsApi - factory interface
 */
export const VersionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VersionsApiFp(configuration)
    return {
        /**
         * Set a specific version as the active (current) version for the application.
         * @summary Set active version
         * @param {string} appKey Unique application key
         * @param {SetActiveVersionRequest} [setActiveVersionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsAppKeyActiveVersionPut(appKey: string, setActiveVersionRequest?: SetActiveVersionRequest, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponse> {
            return localVarFp.appsAppKeyActiveVersionPut(appKey, setActiveVersionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Public endpoint to get the currently active version for an application. Used by clients/devices to check for updates.
         * @summary Get latest (active) version
         * @param {string} appKey Unique application key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsAppKeyLatestGet(appKey: string, options?: RawAxiosRequestConfig): AxiosPromise<LatestVersion> {
            return localVarFp.appsAppKeyLatestGet(appKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all versions for an application with their files.
         * @summary List all versions
         * @param {string} appKey Unique application key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsAppKeyVersionsGet(appKey: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Version>> {
            return localVarFp.appsAppKeyVersionsGet(appKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload one or more files as a new version. Automatically sets as active version.
         * @summary Upload new version
         * @param {string} appKey Unique application key
         * @param {Array<File>} files Files to upload
         * @param {string} [versionName] Version name (auto-generated if not provided)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsAppKeyVersionsPost(appKey: string, files: Array<File>, versionName?: string, options?: RawAxiosRequestConfig): AxiosPromise<UploadVersionResponse> {
            return localVarFp.appsAppKeyVersionsPost(appKey, files, versionName, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific version and its files. Cannot delete the active version.
         * @summary Delete version
         * @param {string} appKey Unique application key
         * @param {string} versionId Version ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsAppKeyVersionsVersionIdDelete(appKey: string, versionId: string, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponse> {
            return localVarFp.appsAppKeyVersionsVersionIdDelete(appKey, versionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VersionsApi - object-oriented interface
 */
export class VersionsApi extends BaseAPI {
    /**
     * Set a specific version as the active (current) version for the application.
     * @summary Set active version
     * @param {string} appKey Unique application key
     * @param {SetActiveVersionRequest} [setActiveVersionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public appsAppKeyActiveVersionPut(appKey: string, setActiveVersionRequest?: SetActiveVersionRequest, options?: RawAxiosRequestConfig) {
        return VersionsApiFp(this.configuration).appsAppKeyActiveVersionPut(appKey, setActiveVersionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Public endpoint to get the currently active version for an application. Used by clients/devices to check for updates.
     * @summary Get latest (active) version
     * @param {string} appKey Unique application key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public appsAppKeyLatestGet(appKey: string, options?: RawAxiosRequestConfig) {
        return VersionsApiFp(this.configuration).appsAppKeyLatestGet(appKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all versions for an application with their files.
     * @summary List all versions
     * @param {string} appKey Unique application key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public appsAppKeyVersionsGet(appKey: string, options?: RawAxiosRequestConfig) {
        return VersionsApiFp(this.configuration).appsAppKeyVersionsGet(appKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload one or more files as a new version. Automatically sets as active version.
     * @summary Upload new version
     * @param {string} appKey Unique application key
     * @param {Array<File>} files Files to upload
     * @param {string} [versionName] Version name (auto-generated if not provided)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public appsAppKeyVersionsPost(appKey: string, files: Array<File>, versionName?: string, options?: RawAxiosRequestConfig) {
        return VersionsApiFp(this.configuration).appsAppKeyVersionsPost(appKey, files, versionName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific version and its files. Cannot delete the active version.
     * @summary Delete version
     * @param {string} appKey Unique application key
     * @param {string} versionId Version ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public appsAppKeyVersionsVersionIdDelete(appKey: string, versionId: string, options?: RawAxiosRequestConfig) {
        return VersionsApiFp(this.configuration).appsAppKeyVersionsVersionIdDelete(appKey, versionId, options).then((request) => request(this.axios, this.basePath));
    }
}



